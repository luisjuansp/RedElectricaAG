<!DOCTYPE html  PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"><html xmlns:mwsh="http://www.mathworks.com/namespace/mcode/v1/syntaxhighlight.dtd">   <head>      <meta http-equiv="Content-Type" content="text/html; charset=utf-8">         <!--This HTML is auto-generated from an M-file.To make changes, update the M-file and republish this document.      -->      <title>Problemas con enga&ntilde;os concatenados e intercalados</title>      <meta name="generator" content="MATLAB 7.3">      <meta name="date" content="2008-08-27">      <meta name="m-file" content="Problemas-con-enga&ntilde;os"><style>body {  background-color: white;  margin:10px;}h1 {  color: #990000;   font-size: x-large;}h2 {  color: #990000;  font-size: medium;}/* Make the text shrink to fit narrow windows, but not stretch too far in wide windows. */ p,h1,h2,div.content div {  max-width: 600px;  /* Hack for IE6 */  width: auto !important; width: 600px;}pre.codeinput {  background: #EEEEEE;  padding: 10px;}@media print {  pre.codeinput {word-wrap:break-word; width:100%;}} span.keyword {color: #0000FF}span.comment {color: #228B22}span.string {color: #A020F0}span.untermstring {color: #B20000}span.syscmd {color: #B28C00}pre.codeoutput {  color: #666666;  padding: 10px;}pre.error {  color: red;}p.footer {  text-align: right;  font-size: xx-small;  font-weight: lighter;  font-style: italic;  color: gray;}  </style></head>   <body>      <div class="content">         <h1>Problemas con enga&ntilde;os concatenados e intercalados</h1>         <introduction>            <p>En este script probamos los resultados de Godlberg para problemas enga&ntilde;osos</p>         </introduction>         <h2>Contents</h2>         <div>            <ul>               <li><a href="#1">Problemas enga&ntilde;osos concatenados, una corrida</a></li>               <li><a href="#2">Problemas enga&ntilde;osos concatenados, curva del mejor encontrado</a></li>               <li><a href="#3">Problemas enga&ntilde;osos intercalados, una corrida</a></li>               <li><a href="#4">Problemas enga&ntilde;osos intercalados, curva del mejor encontrado</a></li>            </ul>         </div>         <h2>Problemas enga&ntilde;osos concatenados, una corrida<a name="1"></a></h2>         <p>Primero, una sola corrida para afinar el tama&ntilde;o de pobalci&oacute;n</p><pre class="codeinput">n = 400;            <span class="comment">% tama&ntilde;o de poblaci&oacute;n</span>k = 5;              <span class="comment">% orden de enga&ntilde;o</span>m = 10;             <span class="comment">% n&uacute;mero de enga&ntilde;os</span>generaciones = 200;objCon = @(x) sum(deceptive(x,k));p = population(<span class="string">'i'</span>,k*ones(1,m));p = random(p,n);p = evaluate(p,objCon);best = get(p,<span class="string">'best'</span>);e = 0;b = best.fitness;<span class="keyword">for</span> i=1:generaciones   p = sus(p);   p = crossover(p);   p = mutation(p);   p = evaluate(p,objCon);   best = get(p,<span class="string">'best'</span>);   e(i+1) = get(p,<span class="string">'evals'</span>);   b(i+1) = best.fitness;   plot(e,b,<span class="string">'.-'</span>)   xlabel(<span class="string">'Evaluaciones de la funci&oacute;n objetivo'</span>)   ylabel(<span class="string">'Mejor encontrado'</span>)   title(sprintf(<span class="string">'%d enga&ntilde;os concatenados de orden %d'</span>,m,k))   pause(0.01)<span class="keyword">end</span></pre><img vspace="5" hspace="5" src="Problemas-con-enganos_01.png"> <h2>Problemas enga&ntilde;osos concatenados, curva del mejor encontrado<a name="2"></a></h2>         <p>Ahora obtenemos la curva completa</p><pre class="codeinput">corridas = 50;E = [];Be = [];p = population(<span class="string">'i'</span>,k*ones(1,m));<span class="keyword">for</span> j=1:corridas   p = init(p);   p = random(p,n);   p = evaluate(p,objCon);   best = get(p,<span class="string">'best'</span>);   e = get(p,<span class="string">'evals'</span>);   b = best.fitness;   <span class="keyword">for</span> i=1:generaciones      p = sus(p);      p = crossover(p);      p = mutation(p);      p = evaluate(p,objCon);      best = get(p,<span class="string">'best'</span>);      e(i+1) = get(p,<span class="string">'evals'</span>);      b(i+1) = best.fitness;   <span class="keyword">end</span>   E = [E e'];   Be = [Be b'];   x = max(E,[],2);   prom = mean(Be,2);   fig1 = std(Be,[],2);   plot(x,prom+fig1,x,prom,<span class="string">'.-'</span>,x,prom-fig1,e,b,<span class="string">'-.k'</span>)   xlabel(<span class="string">'Evaluaciones de la funci&oacute;n objetivo'</span>)   ylabel(<span class="string">'Mejor encontrado'</span>)   title(sprintf(<span class="string">'%d enga&ntilde;os concatenados de orden %d (%d corridas)'</span>,m,k,j))   legend(<span class="string">'prom + std dev'</span>,<span class="string">'prom'</span>,<span class="string">'prom - std dev'</span>,<span class="string">'ultima corrida'</span>,0)   pause(0.01)<span class="keyword">end</span>plot(x,prom+fig1,x,prom,<span class="string">'.-'</span>,x,prom-fig1)<span class="comment">%axis([0 max(max(E)) 0 ceil(logB(2^N,B))])</span>xlabel(<span class="string">'Evaluaciones de la funci&oacute;n objetivo'</span>)ylabel(<span class="string">'Mejor encontrado'</span>)title(sprintf(<span class="string">'Curva del mejor encontrado para %d corridas'</span>,j))legend(<span class="string">'prom + std dev'</span>,<span class="string">'prom'</span>,<span class="string">'prom - std dev'</span>,0)</pre><img vspace="5" hspace="5" src="Problemas-con-enganos_02.png"> <h2>Problemas enga&ntilde;osos intercalados, una corrida<a name="3"></a></h2>         <p>Primero, una sola corrida</p><pre class="codeinput">n = 400;            <span class="comment">% tama&ntilde;o de poblaci&oacute;n</span>k = 5;              <span class="comment">% orden de enga&ntilde;o</span>m = 10;             <span class="comment">% n&uacute;mero de enga&ntilde;os</span>generaciones = 200;objInter = @(x) sum(interDeceptive(x,m));p = population(<span class="string">'i'</span>,m*ones(1,k));p = random(p,n);p = evaluate(p,objInter);best = get(p,<span class="string">'best'</span>);e = 0;b = best.fitness;<span class="keyword">for</span> i=1:generaciones   p = sus(p);   p = crossover(p);   p = mutation(p);   p = evaluate(p,objInter);   best = get(p,<span class="string">'best'</span>);   e(i+1) = get(p,<span class="string">'evals'</span>);   b(i+1) = best.fitness;   plot(e,b,<span class="string">'.-'</span>)   xlabel(<span class="string">'Evaluaciones de la funci&oacute;n objetivo'</span>)   ylabel(<span class="string">'Mejor encontrado'</span>)   title(sprintf(<span class="string">'%d enga&ntilde;os intercalados de orden %d'</span>,m,k))   pause(0.01)<span class="keyword">end</span></pre><img vspace="5" hspace="5" src="Problemas-con-enganos_03.png"> <h2>Problemas enga&ntilde;osos intercalados, curva del mejor encontrado<a name="4"></a></h2>         <p>Ahora obtenemos la curva completa</p><pre class="codeinput">corridas = 50;E = [];Be = [];p = population(<span class="string">'i'</span>,m*ones(1,k));<span class="keyword">for</span> j=1:corridas   p = init(p);   p = random(p,n);   p = evaluate(p,objInter);   best = get(p,<span class="string">'best'</span>);   e = get(p,<span class="string">'evals'</span>);   b = best.fitness;   <span class="keyword">for</span> i=1:generaciones      p = sus(p);      p = crossover(p);      p = mutation(p);      p = evaluate(p,objInter);      best = get(p,<span class="string">'best'</span>);      e(i+1) = get(p,<span class="string">'evals'</span>);      b(i+1) = best.fitness;   <span class="keyword">end</span>   E = [E e'];   Be = [Be b'];   x = max(E,[],2);   prom = mean(Be,2);   fig1 = std(Be,[],2);   plot(x,prom+fig1,x,prom,<span class="string">'.-'</span>,x,prom-fig1,e,b,<span class="string">'-.k'</span>)   xlabel(<span class="string">'Evaluaciones de la funci&oacute;n objetivo'</span>)   ylabel(<span class="string">'Mejor encontrado'</span>)   title(sprintf(<span class="string">'%d enga&ntilde;os intercalados de orden %d (%d corridas)'</span>,m,k,j))   legend(<span class="string">'prom + std dev'</span>,<span class="string">'prom'</span>,<span class="string">'prom - std dev'</span>,<span class="string">'ultima corrida'</span>,0)   pause(0.01)<span class="keyword">end</span>plot(x,prom+fig1,x,prom,<span class="string">'.-'</span>,x,prom-fig1)<span class="comment">%axis([0 max(max(E)) 0 ceil(logB(2^N,B))])</span>xlabel(<span class="string">'Evaluaciones de la funci&oacute;n objetivo'</span>)ylabel(<span class="string">'Mejor encontrado'</span>)title(sprintf(<span class="string">'Curva del mejor encontrado para %d corridas'</span>,j))legend(<span class="string">'prom + std dev'</span>,<span class="string">'prom'</span>,<span class="string">'prom - std dev'</span>,0)</pre><img vspace="5" hspace="5" src="Problemas-con-enganos_04.png"> <p class="footer"><br>            Published with MATLAB&reg; 7.3<br></p>      </div>      <!--##### SOURCE BEGIN #####%% Problemas con engaños concatenados e intercalados% En este script probamos los resultados de Godlberg para problemas% engañosos%% Problemas engañosos concatenados, una corrida% Primero, una sola corrida para afinar el tamaño de pobalciónn = 400;            % tamaño de poblaciónk = 5;              % orden de engañom = 10;             % número de engañosgeneraciones = 200; objCon = @(x) sum(deceptive(x,k));p = population('i',k*ones(1,m));p = random(p,n);p = evaluate(p,objCon);best = get(p,'best');e = 0;b = best.fitness;for i=1:generaciones   p = sus(p);   p = crossover(p);   p = mutation(p);   p = evaluate(p,objCon);   best = get(p,'best');   e(i+1) = get(p,'evals');   b(i+1) = best.fitness;   plot(e,b,'.-')   xlabel('Evaluaciones de la función objetivo')   ylabel('Mejor encontrado')   title(sprintf('%d engaños concatenados de orden %d',m,k))   pause(0.01)end%% Problemas engañosos concatenados, curva del mejor encontrado% Ahora obtenemos la curva completacorridas = 50;E = [];    Be = [];p = population('i',k*ones(1,m));for j=1:corridas   p = init(p);   p = random(p,n);   p = evaluate(p,objCon);   best = get(p,'best');   e = get(p,'evals');   b = best.fitness;   for i=1:generaciones      p = sus(p);      p = crossover(p);      p = mutation(p);      p = evaluate(p,objCon);      best = get(p,'best');      e(i+1) = get(p,'evals');      b(i+1) = best.fitness;   end   E = [E e'];   Be = [Be b'];   x = max(E,[],2);   prom = mean(Be,2);   fig1 = std(Be,[],2);   plot(x,prom+fig1,x,prom,'.-',x,prom-fig1,e,b,'-.k')   xlabel('Evaluaciones de la función objetivo')   ylabel('Mejor encontrado')   title(sprintf('%d engaños concatenados de orden %d (%d corridas)',m,k,j))   legend('prom + std dev','prom','prom - std dev','ultima corrida',0)   pause(0.01)endplot(x,prom+fig1,x,prom,'.-',x,prom-fig1)%axis([0 max(max(E)) 0 ceil(logB(2^N,B))])xlabel('Evaluaciones de la función objetivo')ylabel('Mejor encontrado')title(sprintf('Curva del mejor encontrado para %d corridas',j))legend('prom + std dev','prom','prom - std dev',0)%% Problemas engañosos intercalados, una corrida% Primero, una sola corridan = 400;            % tamaño de poblaciónk = 5;              % orden de engañom = 10;             % número de engañosgeneraciones = 200; objInter = @(x) sum(interDeceptive(x,m));p = population('i',m*ones(1,k));p = random(p,n);p = evaluate(p,objInter);best = get(p,'best');e = 0;b = best.fitness;for i=1:generaciones   p = sus(p);   p = crossover(p);   p = mutation(p);   p = evaluate(p,objInter);   best = get(p,'best');   e(i+1) = get(p,'evals');   b(i+1) = best.fitness;   plot(e,b,'.-')   xlabel('Evaluaciones de la función objetivo')   ylabel('Mejor encontrado')   title(sprintf('%d engaños intercalados de orden %d',m,k))   pause(0.01)end%% Problemas engañosos intercalados, curva del mejor encontrado% Ahora obtenemos la curva completacorridas = 50;E = [];    Be = [];p = population('i',m*ones(1,k));for j=1:corridas   p = init(p);   p = random(p,n);   p = evaluate(p,objInter);   best = get(p,'best');   e = get(p,'evals');   b = best.fitness;   for i=1:generaciones      p = sus(p);      p = crossover(p);      p = mutation(p);      p = evaluate(p,objInter);      best = get(p,'best');      e(i+1) = get(p,'evals');      b(i+1) = best.fitness;   end   E = [E e'];   Be = [Be b'];   x = max(E,[],2);   prom = mean(Be,2);   fig1 = std(Be,[],2);   plot(x,prom+fig1,x,prom,'.-',x,prom-fig1,e,b,'-.k')   xlabel('Evaluaciones de la función objetivo')   ylabel('Mejor encontrado')   title(sprintf('%d engaños intercalados de orden %d (%d corridas)',m,k,j))   legend('prom + std dev','prom','prom - std dev','ultima corrida',0)   pause(0.01)endplot(x,prom+fig1,x,prom,'.-',x,prom-fig1)%axis([0 max(max(E)) 0 ceil(logB(2^N,B))])xlabel('Evaluaciones de la función objetivo')ylabel('Mejor encontrado')title(sprintf('Curva del mejor encontrado para %d corridas',j))legend('prom + std dev','prom','prom - std dev',0)##### SOURCE END #####-->   </body></html>